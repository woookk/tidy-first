# 03. 이론

- **목차**
    - [Chapter 22. 요소들을 유익하게 관계 맺는 일](#chapter-22-요소들을-유익하게-관계-맺는-일)
    - [Chapter 23. 구조와 동작](#chapter-23-구조와-동작)
    - [Chapter 24. 경제 이론: 시간 가치와 선택 가능성](#chapter-24-경제-이론-시간-가치와-선택-가능성)
    - [Chapter 25. 오늘의 1달러가 내일의 1달러보다 크다](#chapter-25-오늘의-1달러가-내일의-1달러보다-크다)
    - [Chapter 26. 옵션](#chapter-26-옵션)
    - [Chapter 27. 옵션과 현금흐름 비교](#chapter-27-옵션과-현금흐름-비교)
    - [Chapter 28. 되돌릴 수 있는 구조 변경](#chapter-28-되돌릴-수-있는-구조-변경)
    - [Chapter 29. 결합도](#chapter-29-결합도)
    - [Chapter 30. 콘스탄틴의 등가성](#chapter-30-콘스탄틴의-등가성)
    - [Chapter 31. 결합도와 결합도 제거](#chapter-31-결합도와-결합도-제거)
    - [Chapter 32. 응집도](#chapter-32-응집도)
    - [Chapter 33. 결론](#chapter-33-결론)
    - [스터디](#스터디)

지금까지 무엇을, 언제, 어떻게 정리해야 하는지 알아보았으니, 이제 코드를 정리해야 하는 이유에 대해 이야기한다.

**이론을 이해하면 최적의 응용이 가능**하다.

소프트웨어 설계에서 영원한 질문이 있다.

- 언제 소프트웨어 설계 결정을 시작해야 하는가?
- 언제 소프트웨어 설계 결정을 중단하고 시스템의 동작을 변경해야 하는가?
- 다음 결정은 어떻게 내릴 것인가?

이러한 질문은 당장 합리적이고 논리적으로 답할 수 없다. 그 시점에는 합리적이고 논리적인 답을 찾는데 필요한 정보가 존재하지 않기 때문이다.

이론을 이해하면, 이러한 질문에 추측으로 답해야 할 때를 대비해 판단력을 키울 수 있다.

다음과 같은 내용을 설명한다.

1. 소프트웨어 설계란 무엇인가?
2. 소프트웨어 설계가 소프트웨어 개발과 운영 비용을 어떻게 좌우하는가? 반대로, 소프트웨어 개발과 운영 비용이 소프트웨어 설계를 어떻게 좌우하는가?
3. 소프트웨어 구조에 투자할 때와 투자하지 않을 때 장단점은 무엇인가?
4. 소프트웨어 구조를 변경할지 여부와 방법을 결정할 때 어떤 경제적, 인간적 원칙을 사용할 수 있는가?

# Chapter 22. 요소들을 유익하게 관계 맺는 일

소프트웨어 설계란 무엇인가?

‘**소프트웨어 설계는 인간 관계 속에서 벌어지는 활동**’이다.
‘**소프트웨어 설계의 의미’에 대해 ‘요소들을 유익하게 관계 맺는 일**’이라고 말할 수 있다.

단어 하나하나에 상당한 무게가 담겼다고 할 수 있다. 이 단어들을 하나씩 나눠서 살펴 보고 다시 조합해 보겠다.

### 요소

- 세포소기관 → 기관 → 유기체
- 원자 → 분자 → 결정
- 프로그래밍 세계에서는, 토큰 → 식(expression) → 문(statement) → 함수 → 객체 / 모듈 → 시스템

요소에는 경계가 있다. 그래서 어디에서 시작하고 끝나는지 알 수 있다.

또한 요소는 하위 요소를 포함한다. 프로그래머들은 보통 ‘컴포지트(Compsite) 패턴’과 같은 동질적인 계층 구조를 선호한다. 하지만, 앞의 예시처럼 자연의 계층 구조는 동질적이지 않다. 하위 요소는 이들을 포함하는 요소와 다르다.

### 관계 맺기

요소들은 서로 관계를 지닌 존재들이다. 하나의 함수가 다른 함수를 호출한다. 이때, 함수가 바로 그 요소를 이뤄서, ‘호출하고/호출받는’ 관계를 맺는다.

소프트웨어 설계에서 관계는 다음과 같은 것들이 있다.

- 호출
- 발행(Publish)
- 대기(Listen)
- 참조(변수의 값을 가져오기)

### 유익하게

설계할 때, 시스템에는 필요하지만, 기계를 위한 명령어가 아닌, 일종의 중간 요소를 만들면, 그 중간 요소들이 서로에게 도움이 되기 시작한다.

### 요소들을 유익하게 관계 맺는 일

‘요소들을 유익하게 관계 맺는 일’이라는 문구는 ‘설계는…’으로 시작한다. 설계란 무엇일까?

**설계를 구성하는 요소들과 그들의 관계, 그리고 그 관계에서의 파생되는 이점이 바로 설계**이다.

설계자는 어떤 일을 할까?

설계자는 요소들을 유익하게 관계 맺는 일을 한다. 이러한 관점에서 소프트웨어 설계자는 다음과 같은 일만 할 수 있다.

- 요소를 만들고 삭제한다.
- 관계를 만들고 삭제한다.
- 관계의 이점을 높인다.

정리하면, 시스템의 구조는 다음과 같다.

- 요소 계층 구조
- 요소 사이의 관계
- 이러한 관계가 만들어내는 이점

# Chapter 23 구조와 동작

소프트웨어는 두 가지 방식으로 가치를 만든다.

- 현재 소프트웨어가 하는 일
- 미래에 새로운 일을 시킬 수 있는 가능성

‘현재 소프트웨어가 하는 일’은 시스템 동작을 말한다. 동작을 규정하는 방식은 다음 두 가지이다.

- 입출력 쌍
- 불변 조건

이처럼 동작은 직접적인 가치를 만든다. 컴퓨터가 매초 수백만 번의 계산을 수행해준다면, 사용자는 손으로 계산하는 시간을 들일 필요가 없다. 그 편리함에 기꺼이 비용을 지불하는 이들이 많다면, 전기료가 1달러 들더라도 10달러에 해당하는 서비스를 제공하여 비즈니스를 성립시킬 수 있다.

그렇다면 1달러를 넣었을 때 10달러를 내놓는 기계보다, 10달러를 넣을 때마다 100달러를 내놓는 기계가 더 낫지 않은가? 여기서 중요한 것은 “어떻게 하면 더 나은 기계(시스템)에 도달할 수 있을까?”라는 질문이다.

그 해답은 한 마디로 **‘선택 가능성’** 이다. 특정 방식으로 동작하는 시스템이 일단 존재하게 되면, 사람들은 “이 시스템을 더 활용할 다른 방법은 없을까?”라는 의문을 갖는다. 이때 당장 시스템의 동작을 바꾸지 않아도, **선택할 수 있는 ‘가능성’을 열어두는 순간부터 이미 추가 가치가 발생**한다.

> 하이젠베르크 불확실성의 원리
> 
> 물리학의 이 원리는 대상을 관찰하는 과정에서 그 대상의 상태가 변하여 완벽한 파악이 어려워짐을 의미한다. 소프트웨어에서도 마찬가지다. 미래 요구사항, 시장 변화, 새로운 기능 도입을 고려하기 시작하는 순간, 시스템을 완전히 예측하거나 명확히 이해하기가 쉽지 않다. 이런 불확실성이 커질수록, 더 많은 선택지(옵션)를 확보하는 구조적 유연성이 그만큼 더 큰 가치를 발휘한다.

**옵션은 소프트웨어로 만들어내는 경제적인 마법이며, 주로 확장할 기회를 만든다.** 옵션의 가장 멋진 점 중 하나는 환경의 변동성이 클 수록 옵션의 가치가 더 커진다는 것이다. 현재 시스템이 1천 개의 알람을 보낼 수 있다면, 구조적 투자와 설계를 통해 10만 개의 알람도 보낼 수 있는 기반을 마련해둘 수 있다. 불확실한 미래일수록 더욱 귀중한 것은 바로 이러한 선택 가능성이다.

시스템의 구조는 동작에 영향을 미치지 않는다. 구조는 미래의 기회를 만든다. 문제는 구조가 동작처럼 또렷하게 드러나지 않는다는 사실이다. 선택 가능성을 유지하고 확장하기 위해 구조에 투자해야 한다고 알고 있지만, 그 투자가 충분했는지, 실제로 기대한 수준의 유연성을 제공하는지는 명확히 판단하기 어렵다. 코드 변경이 가능하다 한들, 그것이 정말 충분히 쉽고 유용한 형태인지는 확신하기 어렵다.

**결국 구조 변경과 동작 변경은 모두 가치를 만들어내지만, 서로 다른 성격을 가진다는 점을 이해**해야 한다. 이를 가역성 측면에서 바라보면, **동작 변경은 즉각적인 결과를 보여주지만 되돌리기 어렵고**, **구조 변경은 미래의 가능성을 준비하나 가시성이 낮다.** **이 차이를 이해하는 순간, 우리는 소프트웨어 설계와 발전에 있어 더 나은 판단**을 내릴 수 있을 것이다.

# Chapter 24. 경제 이론: 시간 가치와 선택 가능성

소프트웨어 설계는 ‘먼저 벌고 나중에 써야 한다’와 ‘물건이 아닌 옵션을 만들어야 한다’는 두 가지 속성을 조화시켜야 한다.

> [!NOTE]
> 돈의 본성은 두 가지 속성을 지닌다.
> 
> - 오늘의 1달러가 내일의 1달러보다 더 가치가 있기 때문에 버는 것은 빨리하고, 쓰는 것은 가능한 뒤로 미룬다.
> - 혼란스러운 상황에서는 어떤 물건에 대한 옵션이 물건 자체보다 낫기 때문에 불확실성에 맞서는 옵션을 만든다.

# Chapter 25. 오늘의 1달러가 내일의 1달러보다 크다.

많고 적음의 의미는 항상 같을까? 상황에 따라 다르다. 돈에 대해서라면, 다음 두 가지에 달렸다.

- 시점
- 확실성

소프트웨어 시스템의 가치는 어떻게 평가할까? 소프트웨어의 가치를 평가하기 위해 일부는 유입되고 일부는 유출되는 일련의 현금흐름으로 모델링할 수 있지만, 각 흐름은 날짜와 밀접하게 연결되어 있다.

정리하면, 소프트웨어 시스템의 경제적 가치는 할인된 미래의 현금흐름의 합으로 설명할 수 있다.

> 이 책의 범위에서 돈의 시간 가치는 코드 정리를 먼저 하기보다는 나중에 하는 것을 권장한다. 지금 당장 돈을 벌고 나중에 코드를 정리하는 행동 변화를 실천할 수 있다면 점차 먼저 돈을 벌고 나중에 돈을 쓸 수 있을 것이다.
>

# Chapter 26. 옵션

- “다음에 어떤 동작을 구현할 수 있을까?”라는 질문은 동작을 구현하기 전에도, 그 자체로 가지가 있다.
- “다음에 어떤 동작을 구현할 수 있을까?”라는 질문은 동작 후보 목록이 많을수록 더 가치가 있다. 목록의 규모를 늘릴 수 있다면 가치를 창출한 것이다.
- 어떤 항목이 가장 가치가 있을지는 구현할 수 잇는 옵션을 계속 열어두는 한 신경 쓸 필요가 없다.
- 가치에 대한 예측이 불확실할수록 바로 구현하는 것보다 옵션이 지닌 가치가 더 커진다.

> 오늘 우리가 하는 설계는 내일의 동작 변경을 ‘구매’하는 ‘옵션’에 대해 지불하는 프리미엄이다.
>

소프트웨어 설계를 옵션의 관점에서 생각하면 생각이 완전히 뒤집힐 수 있다. 옵션을 만드는 것과 동작을 변경하는 것의 균형을 맞추는 데 집중하자.

# Chapter 27. 옵션과 현금흐름 비교

- **현금흐름할인**은 높은 확률로 먼저 돈을 벌고, 낮은 확률로 나중에 돈을 쓰라고 말한다. 코드 정리를 먼저 하지 말아라. 돈을 더 일찍 쓰고, 돈을 나중에 버는 것이다. 어쩌면 나중에는 정리가 필요하지 않을 수도 있다.
- **옵션**은 나중에 더 많은 돈을 벌기 위해 설사 정확한 방법을 모르더라도, 지금 돈을 쓰라고 말한다. 옵션이 생길 일이 명백하다면, 코드 정리를 선행하자. 동작 변경 후에도 정리할 내용이 있다면 또 한다.

확실히 코드 정리부터 해야 할 때가 있다.

> 비용(코드 정리) + 비용(코드 정리 후 동작 변경) < 비용(바로 동작 변경)
>

위 수식이 성립되면 무조건 코드 정리를 먼저 하자. 어느 정도까지 할 것인지 경계를 잘 설정하고 유지하자.

다음과 같은 상황에서

> 비용(코드 정리) + 비용(코드 정리 후 동작 변경) > 비용(바로 동작 변경)
>

단기적인 경제성 때문에 코드 정리가 망설여지더라도 코드 정리를 먼저 하고 싶을 수 있다. 그리고 코드 정리 과정에서 자연스럽게 동작 변경까지 하고 있을 수도 있다. 모든 변경에 걸쳐 코드 정리에 드는 비용을 나누는 것이 합리적일 수 있으며, 현금흐름을 할인하는 것도 가능하다.

창출된 옵션의 가치가 더 빨리 그리고 확실하게 돈을 지출함으로써 잃는 가치보다 크다면 현금흐름이 할인되더라도 코드 정리를 우선하는 것이 오히려 경제적으로 합리적일 수 있다. 이 지점은 확고한 판단의 갈림길이다.

**몇 분에서 몇 시간에 이르는 코드 정리 규모에서 코드 정리의 경제성을 정확하게 계산할 수 없으며, 계산하려고 시도해서도 안된다.** **두 가지 중요한 판단력을 길러서, 나중에 더 큰 일을 실행**하려고 하자.

- **소프트웨어 설계의 시기와 범위에 영향을 미치는 인센티브를 인식하는 데 익숙해지기**
- **대인 관계 기술을 우리 자신에게 연습해서, 나중에 밀접하게 일하는 동료부터 더 넓은 범위의 동료에게까지 활용**하자

# Chapter 28. 되돌릴 수 있는 구조 변경

선행(先行) 코드 정리 작업의 가장 큰 장점 중 하나는 구조 변경의 상당수가 ‘되돌릴 수 있다’는 점이다. 만약 구조 변경 결과가 마음에 들지 않는다면, 언제든지 원래 상태로 되돌릴 수 있다.

이와 대조적으로, 잘못된 방향으로 이루어진 동작 변경은 되돌리기 쉽지 않다. 동작 변경은 시스템이 실제로 수행하는 일을 바꾸는 것이므로, 이를 원상태로 복구하려면 훨씬 더 큰 비용과 노력이 필요하다.

일반적으로 되돌릴 수 있는 결정은 되돌릴 수 없는 결정과는 달리 비교적 가벼운 마음으로 내릴 수 있다. 반면에 되돌릴 수 없는 결정에 대해서는 더욱 면밀히 검토하고, 필요하다면 여러 차례 확인을 거치는 과정이 반드시 뒤따라야 한다. 이러한 신중함이 결국 시스템의 안정성과 유연성을 높여주기 때문이다.

# Chapter 29. 결합도

한 요소를 변경하면 다른 요소도 함께 변경해야 하는 경우, 두 요소는 특정 변경과 관련하여 서로 결합되어 있다.

- 일대다: 어떤 변경이 일어나면 한 요소는 여러 요소와 결합이 일어난다.
- 연쇄 작용: 일단 변경이 일어나면 한 요소에서 다른 요소로 변경이 파급되고 그 변경은 수많은 변경을 촉발할 수 있다.

> 결합도는 소프트웨어 비용을 결정하는 중요한 요소이다.
>

# Chapter 30. 콘스탄틴의 등가성

소프트웨어 비용은 그것을 변경하는 데 드는 비용과 거의 같다.

> 비용(소프트웨어) ~= 비용(전체 변경) ~= 비용(큰 변경들) ~= 결합도
>

따라서, 소프트웨어 비용을 줄이려면 결합도를 줄여야 한다. 결합도를 줄이는 것은 공짜가 아니며 절충점을 피할 수 없다.

# Chapter 31. 결합도와 결합도 제거

왜 결합도를 완전히 제거하지 않을까? 도대체 결합도는 왜 있어야 하는걸까?

**한 종류의 코드 변경에 대한 결합도를 줄일수록 다른 종류의 코드 변경에 대한 결합도가 커진다는 것**이다. 이것이 의미하는 실질적인 의미는 모든 결합을 다 색출하듯 없애려고 애쓰지 말아야 한다는 것이다. 그렇게 해서 만들어진 결합도는 그만한 가치가 없다.

![[그림 1. Cost of coupling trades off with cost of decoupling]](/images/part3/cost_of_coupling_trades_off_cost_of_decoupling.png)

# Chapter 32. 응집도

결합된 요소들은 둘을 포함하는 같은 요소의 하위 요소여야 한다. 이것이 응집도가 내포하는 첫 번째 의미이다.

응집도의 두 번째 의미는 결합되지 않은 요소는 다른 곳으로 이동해야 한다는 것이다.

한 번에 한 요소씩 이동하자. 다음에 코드를 볼 사람을 위해 코드를 더 깔끔하게 정리하세요. 모두가 스카우트 규칙을 따른다면, 시간이 지날수록 코드가 더 ‘살기 좋은’ 코드가 될 것입니다.

> [!NOTE]
> **보이스카우트 규칙 (Boy Scout Rule)**
> 
> 보이스카우트 규칙은 “캠핑장을 떠날 때는 왔을 때보다 더 깨끗하게 하라”는 보이스카우트의 전통에서 유래한 것으로, 코드를 수정할 때마다 원래보다 조금이라도 더 개선한 상태로 남겨두자는 원칙을 의미한다. 이를 통해 코드는 시간이 흐를수록 점점 더 깔끔하고 유지보수하기 좋은 상태로 발전해 나갈 수 있다.

# Chapter 33. 결론

책의 제목이기도 한 “코드 정리가 먼저인가?”라는 질문에 답할 준비가 되었는가? 매번 조금씩 다르지만, 다음 네 가지 힘에 의해 영향을 받는다.

- **비용**: 코드를 정리하면 비용이 줄까? 아니면 나중에 하는 편이 나을까? 줄일 가능성이 있을까?
- **수익**: 코드를 정리하면 수익이 더 커질까? 혹은 더 빨리 발생하거나 커질 가능성이 있나?
- **결합도**: 코드를 정리하면 변경이 필요한 요소의 수가 줄어드나?
- **응집도**: 코드를 정리하면 변경을 더 작고 좁은 범위로 집중시켜 더 적은 수의 요소만 다룰 수 있을까?

하지만, 가장 중요한 것은 여러분이다.

그리고, 스스로 코드 정리 연습을 하면서 다른 사람들을 대신하여 설계할 준비를 하고 있다는 사실을 명심하자. 이것이 소프트웨어 설계를 개발의 평범하고 균형잡힌 부분으로 만드는 과정이다.

혼자서 프로그래밍하는 경우는 거의 없다. 설계 요소 간의 결합도가 있는 것처럼 서로 얽혀 있다. 누군가 변경을 하면 서로에게 영향을 끼칠 수 있다.

> 코드 정리를 먼저 하실 건가요? 아마도요. 바로 그것이다. 충분히 그만한 가치가 있다.
---

# 스터디

- 각자 읽고 정리
- 더 얘기해볼 것
- 이해 안가는 부분
- 스터디 내용 관련 경험

## 더 얘기해볼 것

## 이해 안가는 부분

## **추가 자료 및 참고 링크**
- **도서**
- 링크
  - [Dead Code, Getting Untangled, and Coupling versus Decoupling](https://newsletter.pragmaticengineer.com/p/dead-code-getting-untangled-and-coupling)
