# 01. 코드 정리법
코드 변경을 위해 지저분한 코드를 마주칠 때마다 적용할 수 있는 작은 설계 움직임을 다룬다.

코드 정리는 마치 미니어처 같은 **아주 작은 리팩토링**이다. 각각의 짧은 장마다 코드 정리 방법을 다룬다. 그리고 코드 정리 적용 전과 후를 대비하는 코드를 예로 들어 설명한다.

- 목차
  - [Chapter 01. 보호 구문](#chapter-01-보호-구문)
  - [Chapter 02. 안 쓰는 코드](#chapter-02-안-쓰는-코드)
  - [Chapter 03. 대칭으로 맞추기](#chapter-03-대칭으로-맞추기)
  - [Chapter 04. 새로운 인터페이스로 기존 루틴 부르기](#chapter-04-새로운-인터페이스로-기존-루틴-부르기)
  - [Chapter 05. 읽는 순서](#chapter-05-읽는-순서)
  - [Chapter 06. 응집도를 높이는 배치](#chapter-06-응집도를-높이는-배치)
  - [Chapter 07. 선언과 초기화를 함께 옮기기](#chapter-07-선언과-초기화를-함께-옮기기)
  - [Chapter 08. 설명하는 변수](#chapter-08-설명하는-변수)
  - [Chapter 09. 설명하는 상수](#chapter-09-설명하는-상수)
  - [Chapter 10. 명시적인 매개 변수](#chapter-10-명시적인-매개-변수)
  - [Chapter 11. 비슷한 코드끼리](#chapter-11-비슷한-코드끼리)
  - [Chapter 12. 도우미 추출](#chapter-12-도우미-추출)
  - [Chapter 13. 하나의 더미](#chapter-13-하나의-더미)
  - [Chapter 14. 설명하는 주석](#chapter-14-설명하는-주석)
  - [Chapter 15. 불필요한 주석 지우기](#chapter-15-불필요한-주석-지우기)
  - [스터디](#스터디)

## Chapter 01. 보호 구문

보호 구문이 있는 코드라면 전제조건이 명시적으로 드러날 때 분석하기 쉽다. 다만, 보호구문을 남용하면 안된다.

```java
    // Before
    if (!queues.containsKey(queueName)) {
        emitBefore("declare_queue", queueName);
        queues.put(queueName, new Queue());
        emitAfter("declare_queue", queueName);
    
        String delayedName = dqName(queueName);
        queues.put(delayedName, new Queue());
        delayQueues.add(delayedName);
        emitAfter("declare_delay_queue", delayedName);
    }
    
    // After
    if (queues.containsKey(queueName)) {
        return;
    }
    
    emitBefore("declare_queue", queueName);
    queues.put(queueName, new Queue());
    emitAfter("declare_queue", queueName);
    
    String delayedName = dqName(queueName);
    queues.put(delayedName, new Queue());
    delayQueues.add(delayedName);
    emitAfter("declare_delay_queue", delayedName);
```

https://github.com/Bogdanp/dramatiq/pull/470/files

# Chapter 02. 안 쓰는 코드

안 쓰는 코드는 지워버리자. 그게 다이다. 실행되지 않는다면 그냥 지우자.

형상 관리 도구를 쓴다면 문제 될 게 없다. 최악의 상황이 오더라도 언제든 되돌릴 수 있다. 항상 그렇듯이 각 정리 과정에서는 코드를 ‘조금만’ 삭제하자. 그렇게 하면, 잘못 고친 것으로 밝혀져도 쉽게 복구할 수 있다.

# Chapter 03. 대칭으로 맞추기

코드는 마치 유기체처럼 성장한다. 필요한 모든 코드를 한꺼번에 작성할 수는 없기 때문이다.

코드가 유기체로 성장하면, 같은 문제라도 시대와 사람에 따라 다른 모습으로 해결된다. 자연스러운 일이지만, 이것은 코드를 읽기 어렵게 만들기도 한다. 읽는 입장에서는 일관성이 중요하다. 패턴이 보일 경우, 진행되는 것을 알 수 있으므로 확신을 가지고 바로 결정할 수 있다.

한 가지 방식을 선택해서 정하자. 다른 방식으로 작성한 코드를 선택한 방식으로 고치자. 비슷해 보이지만 같지 않은 루틴을 찾아내고 같은 부분들 속에 다른 부분을 분리하자.

![그림 1. 대칭으로 맞추기](/images/part1/대칭으로_맞추기.png)

# Chapter 04. 새로운 인터페이스로 기존 루틴 부르기

루틴을 호출해야 하는데 기존 인터페이스 때문에 어렵거나, 복잡하거나, 혼란스럽거나, 지루해지곤 한다. 이 모든 경우에 호출하고 싶은 인터페이스를 새롭게 구현해서 호출하자.

새롭게 구현한 통로 인터페이스(pass-through interface)는 소프트웨어 설계에서 작은 단위로 중추적 역할을 한다. 동작을 변경해야 할 때, 통로 인터페이스를 이용해 설계를 했다면 변경하기 한층 수월하다.

# Chapter 05. 읽는 순서

코드를 읽을 때 독자의 입장이 되어보자. 읽기 좋은 순서로 다시 정렬하면, 그 순서대로 코드를 만날 수 있다. 여러 사람이 작성한 내용을 서로 보게된다는 사실을 기억하자.

읽는 순서가 영향을 크게 주는 것부터 바꾸자. 완벽한 순서는 없다. 스스로의 경험을 살려  판단하고 순서를 결정하자. 코드를 읽는 다음 사람에게 정렬된 코드를 선물하자.

> [!NOTE]  
> **클린코드 3장 함수 - 함수당 추상화 수준은 하나로!**
> 
> 한 함수 내 추상화 수준을 섞으면 코드를 읽는 사람이 헷갈린다. 특정 표현이 근본 개념인지 아니면 세부사항인지 구분하기 어려운 탓이다.
> 
> **위에서부터 아래로 코드 읽기: 내려가기 규칙**
> 
> 코드는 위에서부터 아래로 이야기처럼 읽혀야 좋다. 한 함수 다음에는 추상화 수준이 한 단계 낮은 함수가 온다. 즉, 위에서 아래로 프로그램을 읽으면 함수 추상화 수준이 한 번에 한 단계씩 낮아진다.
> 
> 함수 추상화 수준이 하나인 함수를 구현하기란 쉽지 않다. 위에서부터 아래로 TO 문단을 읽어내려 가듯이 코드를 구현하면 추상화 수준을 일관되게 유지하기가 쉬워진다.

# Chapter 06. 응집도를 높이는 배치

코드를 읽다가 변경해야 할 동작들을 찾았더니 여러 곳에 흩어져 있는 코드를 함께 바꿔야 한다는 걸 알면 불편한 감정이 일어난다. 어떻게 해야할까?

코드의 순서를 바꿔서 변경할 요소들을 가까이 두면 된다.

같은 디렉토리에 들어있는 파일에도 적용할 수 있다. 두 파일에 결합도가 있다면 같은 디렉토리에 넣자.

결합도를 제거할 수 있다면 그렇게 하자. 그것이 가장 좋은 코드 정리법이다.

> 결합도 제거 비용 + 변경 비용 < 결합도에 따른 비용 + 변경 비용
>

하지만 여러 가지 이유로 결합도 제거가 어려울 수 있다.

- 당장 어떻게 해야할 지 모른다면 결합도 제거가 곤란
- 당장 시간적 여유가 없다면 결합도 제거는 부담스러운 시간 투자
- 팀적으로 충분한 변경을 수행하고 있다면 결합도 제거하는 일이 갈등 유발 가능

# Chapter 07. 선언과 초기화를 함께 옮기기

변수 선언과 초기화 위치는 종종 서로 떨어져 있기도 한다. 보통 변수 이름에서 힌트를 얻어 프로그램에서 역할을 알게 되지만, 변수 초기화는 이름이 주는 의미를 더 강화한다. 타입이 포함된 선언과 초기화 코드가 떨어져 있기라도 하면 읽어내기 더 어렵다. 한참 뒤에야 초기화 코드를 보게 된다면, 변수가 어떤 맥락에서 선언되었는지 잊어버릴 수 있다.

초기화를 변수 선언 근처로 이동하여, 이 문제를 해결하자. 다만, 데이터 종속 순서도 함께 유지해야 한다.

# Chapter 08. 설명하는 변수

코드의 어떤 표현식들은 계속 성장한다. 처음에는 작게 시작했더라도, 시간이 흐르면 코드는 반드시 커진다.

어렵게 크고 복잡한 코드의 표현식을 이해했다면 전체에서 일부 표현식을 추출한 후, 표현식의 의도가 드러나도록 변수 이름을 만들어 할당하자.

```java
// Before
return new Point(
      ...,
      ...
);

// After
x = ...;
y = ...;
return new Point(x, y);
```

이 정리법은, 힘들게 파악한 내용을 다시 코드에 넣는 것이다. 설명하는 변수를 적용하면 표현식과 분리되었기 때문에 다음 번 코드를 변경할 때, 둘 중 하나만 읽으면 되므로 빠르게 변경할 수 있다.

> 언제나 그렇듯이, 코드 정리에 대한 커밋과 동작 변경에 대한 커밋은 분리해야 한다.
>

# Chapter 09. 설명하는 상수

코드를 읽다가 모르는 숫자를 볼 때가 있다.

> 상징적인 상수를 만들자. 리터럴 상수(Literal Constant)로 사용된 곳은 상징적인 상수로 바꾸자.
>

한 번에 바뀌어야 하거나 함께 이해해야 하는 상수들은 한 곳에 모아두고, 다른 이유로 묶인 변수들을 분리하는 후속 작업들을 해야한다.

# Chapter 10. 명시적인 매개 변수

변경하려는 코드를 읽는 중에 루틴에서 다루고 있는 일부 데이터가 명시적으로 전달되지 않는 경우가 있다. 이런 경우 루틴을 나누자. 앞부분에서 매개변수 값을 채운 후, 뒷 부분에서 명시적으로 전달하자.

```java
// Before
public void foo(Params params) {
    // ...params.a... ...params.b...
}

// After
public void foo(Params params) {
    foo_body(params.a, params.b);
}

public void foo_body(int a, int b) {
    // ...a... ...b...
}
```

매개 변수를 명시적으로 드러나게 만든 다음, 함수를 연쇄적으로 호출할 수 있게 준비하자. 이렇게 만들면 코드는 읽기와 테스트, 분석이 쉬워진다.

# Chapter 11. 비슷한 코드끼리

모든 코드 정리 중에서 가장 단순한 정리법이다. 긴 코드 덩어리를 읽다가 구분이 될 때는 두 부분 사이에 빈 줄을 넣어 분리하자.

관련 있는 코드를 뭉쳐두면 다양한 길로 나아갈 수 있다. 작은 소프트웨어 설계로 변화를 더 쉽게 만들 수 있다.

# Chapter 12. 도우미 추출

코드를 보다가 루틴 속 코드 중에서, 목적이 분명하고 나머지 코드와는 상호작용이 적은 코드 블록은 도우미(helper)로 추출한 후에 이름이 붙이자. 이 때, 이름은 작동 방식이 아니라 목적에 따라 짓는다.

이는 ‘메소드 추출’ 리팩토링이라 한다.

도우미를 추출할 때, 몇 가지 특수한 경우가 있다.

1. 큰 루틴 안에서 몇 줄을 변경해야 하는 경우
    - 해당하는 줄들을 도우미로 추출하고, 도우미 안의 내용만 변경한 다음, 적절하다고 판단한 뒤에 도우미를 호출하는 문장에 반영하자.
2. 시간적 결합을 표현하는 경우
    - `a()`가 `b()`보다 앞서 호출되어야 하는 경우

    ```java
    // Before
    foo.a();
    foo.b();
    
    // After
    ab() {
    	a()
    	b()
    }
    ```


# Chapter 13. 하나의 더미

때로는 코드가 여러 개의 작은 조각으로 나뉘어져 있기도 한다. 흩어진 코드는 전체적으로 이해하기 어렵다. 필요한 만큼의 코드를 하나의 더미(One Pile)처럼 느껴질 때까지 모으자. 그리고 깔끔하게 정리하자.

코드를 만드는데, 가장 큰 비용이 들어가는 일은 코드 작성이 아니라 읽고 이해하는 일이다. 코드 정리를 선행하면 더 작은 조각 단위로 결합을 제거하는 길로 제시하여 응집도를 높일 수 있다. 한 번에 기억해야 할 코드의 상세 내용을 줄여준다.

> 인간의 단기 기억 용량은 제한적이어서 보통 7±2개의 정보 덩어리만 유지할 수 있다. 코드가 분산되어 있을 때 각각의 덩어리를 기억해야 하는 부담이 크지만, 관련 코드를 하나로 뭉치면 전체를 하나의 덩어리로 인식할 수 있어 인지 부하가 크게 줄어든다. 이는 코드의 응집도를 높이고 이해도를 향상시키는 핵심 원칙이다.
>

먼저 코드를 한데 모아서 이해하기 어려운 부분을 추출해서 정리해보자. 다음 증상들을 찾아보자

- 길고 반복되는 인자 목록
- 반복되는 코드, 그 중에서도 반복되는 조건문
- 도우미에 대한 부적절한 이름
- 공유되어 변경에 노출된 데이터 구조

# Chapter 14. 설명하는 주석

코드를 읽다가 ‘아, 이건 이렇게 돌아가는거구나!’라는 생각이 드는 순간 그 순간이 소중한 순간이다. 기록하자.

코드에서 명확하지 않은 내용만 골라 적자. 코드의 결함을 발견했다면, 그 즉시 해당 위치에 주석을 달아야 한다.

```java
@Tag(name = "이미지 업로드/업데이트 API")
@RestController
@RequiredArgsConstructor
// 현재는 CloudFront에서 Download Service에 대해 보안그룹 규칙 및 Http Header 설정을 통해 Public 접근을 제한하므로,
// Public 접근 제한을 위한 @Profile 설정이 필요하지 않아 해당 설정을 삭제하였습니다.
// 추후 Public 접근이 가능하게 될 경우, 다시 @Profile 설정을 통해 퍼블릭 접근을 제한할 필요가 있습니다.
public class ImageUploadController {
	private static final int FIRST_FILE_INDEX = 0;
	...
}
```

# Chapter 15. 불필요한 주석 지우기

코드만으로 내용을 모두 이해할 수 있다면 주석은 삭제하자.

코드를 작성하는 목적은 다른 프로그래머에게 컴퓨터가 해야 할 일을 설명하는데 있다. 주석과 코드는 작성할 때와 나중에 볼 때, 시간이 흐르고 나면 서로 맞지 않는 경우가 있다.

> [!NOTE]  
> **클린코드 4장 주석 - 주석은 나쁜 코드를 보완하지 못한다.**
> 
> 주석으로 설명하려 애쓰는 대신 코드를 깔끔하게 정리하는 데 시간을 투자하라. 주석은 오래될수록 코드에서 멀어져 거짓말을 하게 된다.
> 
> **코드로 의도를 표현하라!**
> 
> 많은 경우 주석으로 달려는 설명을 함수로 만들어 표현할 수 있다. 주석이 필요하다고 여겨지는 순간 코드를 재작성하여 주석이 필요 없게 만들 수 있는지 고민하라.

---

# 스터디

- 각자 읽고 정리
- 더 얘기해볼 것
- 이해 안가는 부분
- 스터디 내용 관련 경험

## 더 얘기해볼 것

- 스터디 내용 관련 경험
- 코드 정리 우선순위
- 팀 내 코드 정리 문화 & 문서화(가이드라인)

### 현재, 코드 작성할 때 생각하는 것

1. **변수, 메소드 이름 적절한지 - 어떤 역할, 의도인지 표현할 수 있도록**
2. **메소드 내 추상화 단계 일치**
3. **가독성 있는 코드**
4. **코드 내 통일성**
5. **체크인 하기 전 항상 1~4번 확인**

## 이해 안가는 부분

## **추가 자료 및 참고 링크**

- **도서**
    - 『클린 코드』 3장 함수, 4장 주석 by Robert C. Martin
    - 『리팩토링』 by Martin Fowler
    - 『객체지향의 사실과 오해, 오브젝트』 by 조영호
- 링크

  [Refactoring Home Page](https://refactoring.com/)

  [Summary of 'Clean code' by Robert C. Martin](https://gist.github.com/wojteklu/73c6914cc446146b8b533c0988cf8d29)